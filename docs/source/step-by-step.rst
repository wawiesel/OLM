Step-by-step
------------

The quickstart performed all the stages of library creation in one command. Here we
will go step-by-step and explain in more detail. If you have already created the
reactor library in the quick start.


Inspect the files
~~~~~~~~~~~~~~~~~

The :code:`model.jt.inp` file created contains 
`Jinja <https://jinja.palletsprojects.com/en/3.1.x/templates/#synopsis>`_ 
template directives. This SCALE input template is "expanded" into a proper SCALE
input file using data contained in the :code:`config.olm.json`.

.. code:: text

	=t-depl parm=(bonami,addnux={{static.addnux}})
	pincell model
	{{static.xslib}}

	read composition
	'
	' fuel
	  uo2   10 den={{comp.fuel.density}} 1
			   900
			   92234 {{comp.fuel.uo2.iso.u234}}
			   92235 {{comp.fuel.uo2.iso.u235}}
			   92236 {{comp.fuel.uo2.iso.u236}}
			   92238 {{comp.fuel.uo2.iso.u238}} end
	'
	' clad
	  zirc4 20 1 622 end
	'
	' coolant
	  h2o   30 den={{state.coolant_density}} 1.000000 575 end
	  boron 30 den={{state.coolant_density}} {{state.boron_ppm*1e-6}} 575 end
	'
	end composition

	read celldata
	  latticecell squarepitch
		pitch={{static.pitch}} 30
		fuelr={{static.fuelr}} 10
		cladr={{static.cladr}} 20 end
	end celldata

	read depletion
	  10
	end depletion

	read burndata
	  {%- for pb in time.burndata %}
	  power={{pb.power}} burn={{pb.burn}} down=0 end
	  {%- endfor %}
	end burndata

	read model

	read materials
	  mix=10 pn=1 com="fuel" end
	  mix=20 pn=1 com="clad" end
	  mix=30 pn=2 com="coolant" end
	end materials

	read geom
	  global unit 1
		cylinder 10 {{static.fuelr}}
		cylinder 20 {{static.cladr}}
		cuboid   30 4p{{static.pitch/2.0}}
		media 10 1 10
		media 20 1 20 -10
		media 30 1 30 -20
	  boundary 30 3 3
	end geom

	read bounds
	  all=refl
	end bounds

	end model
	end


Generating inputs
~~~~~~~~~~~~~~~~~

.. code::

    olm create --generate examples/quick_uox/data.olm.json

You will notice that all calculations happen in a work directory, which my default is
next to the :code:`data.olm.json` file as :code:`_work`. It can be changed by setting the environment
variable :code:`SCALE_OLM_WORK`.


Running the SCALE calculations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is the part of the reactor library generation that can take a very long time.
In our quick examples, we change the TRITON runtime parameters to be very fast and
approximate, but typical production calculations of this type can take CPU-days. For
this reason, you may want to run these calculations outside of OLM, for example on
a cluster. The example uses a simple Makefile approach to run the SCALE inputs which
does allow for some parallelism and recovery from keyboard interrupts. The Makefile
generated by OLM has some limited capability to not rerun calculations if they
completed successfully.

OLM has a modular approach to each stage, defined inside the :code:`data.olm.json`. For
the run stage of this example, the following block determines how the run is performed.

.. code::json

    "run": {
        "_type": "scale.olm.run:makefile",
        "nprocs": 3,
        "dry_run": false
    }

The :code:`_type` key specifies a function to run, in this case :code:`makefile` inside the module
`scale.olm.run`. This particular run function allows specification of the number of
processes to use and whether it is a dry run or not. Change the "dry_run" from false
to true before you type.


.. code::

    olm create --run examples/quick_uox/data.olm.json

