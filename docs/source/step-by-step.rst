Step-by-step
------------

The quickstart performed all the stages of library creation in one command. Here we
will go step-by-step and explain in more detail. If you have already created the
reactor library in the quick start.


Generating inputs
~~~~~~~~~~~~~~~~~

.. code::

    olm create --generate examples/quick_uox/data.olm.json

You will notice that all calculations happen in a work directory, which my default is
next to the :code:`data.olm.json` file as :code:`_work`. It can be changed by setting the environment
variable :code:`SCALE_OLM_WORK`.


Running the SCALE calculations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is the part of the reactor library generation that can take a very long time.
In our quick examples, we change the TRITON runtime parameters to be very fast and
approximate, but typical production calculations of this type can take CPU-days. For
this reason, you may want to run these calculations outside of OLM, for example on
a cluster. The example uses a simple Makefile approach to run the SCALE inputs which
does allow for some parallelism and recovery from keyboard interrupts. The Makefile
generated by OLM has some limited capability to not rerun calculations if they
completed successfully.

OLM has a modular approach to each stage, defined inside the :code:`data.olm.json`. For
the run stage of this example, the following block determines how the run is performed.

.. code::json

    "run": {
        "_type": "scale.olm.run:makefile",
        "nprocs": 3,
        "dry_run": false
    }

The :code:`_type` key specifies a function to run, in this case :code:`makefile` inside the module
`scale.olm.run`. This particular run function allows specification of the number of
processes to use and whether it is a dry run or not. Change the "dry_run" from false
to true before you type.


.. code::

    olm create --run examples/quick_uox/data.olm.json

